---
title: 模拟call和apply的原理
copyright: true
permalink: 1
top: 0
date: 2019-07-20 13:14:45
categories:
tags:
---

## 1.模拟 call

call 的特点：

- 可以改变我们当前函数的 this 指向
- 会让当前函数执行

```
Function.prototype.call=function(context){
    context=context?Object(context):window
    context.fn=this
    let args=[]
    for(let i=1;i<arguments.length;i++){
        args.push('arguments['+i+']')
    }
    //利用数组的toString的特性（字符串和数组拼接）
    let r=eval('context.fn('+args+')')
    delete context.fn
    return r
}
```

调用

```
fn1.call(fn2)
```

多个 call

```
//多个call会指向window
fn1.call.call.call(fn2)
```

## 2.模拟 apply

```
Function.prototype.apply=function(context,args){
    context=context?Object(context):window
    context.fn=this
    if(!args){
        return context.fn()
    }
    //利用数组的toString的特性（字符串和数组拼接）
    let r=eval('context.fn('+args+')')
    delete context.fn
    return r
}
```

```
fn1.apply('hello',[1,2,3,4])
```
