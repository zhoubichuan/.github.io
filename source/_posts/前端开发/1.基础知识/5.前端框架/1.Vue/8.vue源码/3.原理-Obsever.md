---
title: 实现一个Obsever
copyright: true
permalink: 1
top: 0
date: 2018-05-01 14:59:29
categories:
- 前端开发
- 1.基础知识
- 框架
- 1.Vue
- 原理
tags:
- vue
- Obsever
---

## Obsever 的实现

### 1.实现对对象的获取操作

利用 Object 中的 defineProperty，在获取数据时触发 get 方法，在设置数据时触发 set 方法

```
let obj = {
  name: "jw",
  age: 19
};

function obsever(obj) {
  if (typeof obj == "object") {
    for (let key in obj) {
      defineReactive(obj, key, obj[key]);
    }
  }
}
function defineReactive(obj, key, value) {
  Object.defineProperty(obj, key, {
    get() {
      console.log("获取数据:"+value);
      return value;
    },
    set(val) {}
  });
}
obsever(obj);

console.log(obj.name);
```

结果：

```
获取数据:jw
jw
```

## 2.实现对对象的设置操作

对 set 进行修改，获取修改后的值，赋值给 value

```
set(val) {
      console.log("你将数据:"+value+",更新成了:"+val);
      value = val;
    }
```

设置数据，会触发 set 方法

```
obj.age=20
```

结果：

```
你将数据:19,更新成了:20
```

## 3.解决嵌套数据的问题

### 如下数据，当我们的数据是嵌套的会出现问题

```
let obj = {
  name: "jw",
  age: {
    age: 19
  }
};
```

修改数据

```
obj.age.age=20
```

结果：

```
获取数据:[object Object]
```

没有触发更新数据的操作

由于对 obsever 中只是对数据中第一层的 key 和 value 进行了遍历，对数据中 value 是否是对象没有管，导致问题产生，所以如果数据中 value 也是一个对象的话我们也要对里面的对象用 defineProperty 定义，所有需要在调用 defineReactive 后，再次调用 obsever(value),产生递归，这样里面的对象也会被拦截

#### 这里我们需要做一些处理

我们需要在 set 和 defineReactive 中设置回调，对数据再次进行监听

```
function defineReactive(obj, key, value) {
  obsever(value);
  Object.defineProperty(obj, key, {
    get() {
      return value;
    },
    set(val) {
      console.log("你将数据:"+value+",更新成了:"+val);
      value = val;
    }
  });
}
```

结果：

```
你将数据:19,更新成了:20
```

### 2.设置数据

修改数据

```
obj.age={
  name:1
}
obj.age.name=2
```

结果：

```
你将数据:[object Object],更新成了:[object Object]
```

出现这种结果是因为我们设置 age 的时候是触发了定义的 defineProperty 方法，但是里面的 name 没有设置 defineProperty，我们应该在设置值的时候也去调用 obsever 方法，当这个 value 是对象时也会添加 defineProperty

所以，需要修改

```
set(val) {
      obsever(val);
      console.log("你将数据:"+value+",更新成了:"+val);
      value = val;
    }
```

结果：

```
你将数据:[object Object],更新成了:[object Object]
你将数据:1,更新成了:2
```

## 如果属性不存在

默认后增加的内容并不会刷新视图

## 如果设置的是数组

数组调用 push 是无效的，Object.defineProperty 不支持数组

修改数据

```
obj.age=[1,2,3,4]
obj.age.push(5)
```

结果：

```
你将数据:[object Object],更新成了:1,2,3,4
```

我们可以重写 push 方法

```
let oldPush = Array.prototype.push;
  Array.prototype.push= function(value) {
    console.log("数据更新了");
    oldPush.call(this, value);
  };
```

结果：

```
你将数据:[object Object],更新成了:1,2,3,4
数据更新了
```

可以在 push 数据的时候进行拦截

### 可以把数组上的所有方法进行重写

```
let arr = ["push", "slice", "shifit", "unshift"];
arr.forEach(method => {
  let oldPush = Array.prototype[method];
  Array.prototype[method] = function(value) {
    console.log("数据更新了");
    oldPush.call(this, value);
  };
});
```

### 数组不能通过长度修改，也不能通过数组的索引进行修改

修改数组的长度

```
obj.age=[1,2,3,4]
obj.age.length--
```

结果：

```
你将数据:[object Object],更新成了:1,2,3,4
```

改变数组长度没有触发更新操作
