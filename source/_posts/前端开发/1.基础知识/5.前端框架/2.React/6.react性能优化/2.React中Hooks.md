---
title: React中Hook的介绍
copyright: true
permalink: 1
top: 0
date: 2019-05-17 16:22:32
categories:
  - 前端开发
  - 1.基础知识
  - 5.前端框架
  - React
  - 6.React性能优化
  - 2.React中Hook的介绍
tags:
  - React
  - React中Hook的介绍
---

### 一个简单的 hooks

首先让我们看一下一个简单的有状态组件：

```js
class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }
  render() {
    return (
      <div>
        <p>You clicked {this.state.count} times</p>
        <button onClick={() => this.setState({ count: this.state.count + 1 })}>
          Click me
        </button>
      </div>
    );
  }
}
```

我们来看一下使用 hooks 后的版本

```js
import { useState } from "react";
function Example() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```

可以看到，Example 变成了一个函数，但这个函数却又自己的状态，同时它还可以更新自己的状态。这个函数之所以这个牛，就是因为它注入了一个 hook--useState，就是这个 hook 让我们的函数变成了一个有状态的函数。

除了 useState 这个 hook 外，还有很多别的 hook，比如 useEffect 提供了类似于 componentDidMount 等生命周期钩子的功能，useContext 提供了上下文的功能等。

Hooks 本质上就是一类特殊的函数，他们可以为你的函数型组件（function component）注入一些特殊的功能。

### React 为什么要搞一个 Hooks

#### 想要复用一个有状态的组件太麻烦了

我们都知道 react 的核心思想就是，将一个页面拆层一堆独立的，可复用的组件，并且用自上而下的单向数据流的形式将这些组件串联起来。但假如你在大型的工作项目中用 react，你会发现你的项目中实际上有很多 react 组件冗长且难以复用。尤其是那些写成 class 的组件，它们本身包含了状态，所以复用这类组件就变得很麻烦。

之前官方推荐的解决方案就是：渲染属性和高阶组件

渲染属性指的是使用一个值为函数的 prop 来传递需要动态渲染的 nodes 或者组件，如果下面的代码可以看到我们的 DataProvider 组件包含了所有跟状态相关的代码，而 Cat 组件可以是一个单纯的展示型组件，这样一来 DataProvider 就可以单独复用了。

```js
import Cat from "components/cat";
class DataProvider extends React.Component {
  constructor(props) {
    super(props);
    this.state = { target: "zbc" };
  }
  render() {
    return <div>{this.props.render(this.state)}</div>;
  }
}
<DataProvider render={data => <Cat target={data.target} />} />;
```

虽然这个模式叫 Render Props，但不是说非用 render 的 props 不可，习惯上大家更长写成下面这种

```js
<DataProvider>{data => <Cat target={data.target} />}</DataProvider>
```

高阶组件这个概念就更好理解了，说白了就是一个函数接受一个组件作为参数，经过一系列加工后，最后返回一个新的组件。看下面的代码示例，withUser 函数就是一个高阶组件，它返回了一个新组件，这个组件具有了它提供的获取用户信息的功能。

```js
const withUser = wrappedComponent => {
  const user = sessionStorage.getItem("user");
  return props => <WrappedComponent user={user} {...props} />;
};
const UserPage = props => (
  <div class="user-container">
    <p>My name is {props.user}!</p>
  </div>
);
export default withUser(UserPage);
```

以上这两种模式看上去都挺不错的，很多库也运用了这种模式，比如我们常用的 React Router 但我们仔细看这两种莫斯，会发现他们会增加我们代码的层级关系。最直观的体现，打开 devtool 看看你的组件层级嵌套是不是很夸张。这时候再回头看我们上一节给出的 hooks 列子，是不是简洁多了，没有多余的层级嵌套。把各种想要的功能写成一个一个可复用的自定义 hook，当你的组件想用什么功能时，直接在组件里调用这个 hook 即可。

#### 生命周期钩子函数里的逻辑太乱了

我们通常希望一个函数只做一件事情，但我们的生命周期钩子函数里通常同时做了很多事情。比如我们需要在 componentDidMount 中发起 ajax 请求获取数据，绑定一些事件监听等等。同时，有时候我们还需要在 componentDidUpdate 做一遍同样的事情。当项目变复杂以后，这一块代码也变得不那么直观。

#### calss 真的太让人困惑了

我们用 class 来创建 react 组件时，还有一件很麻烦的事情，就是 this 的指向问题。为了保证 this 的指向正确，我们要经常写这样的代码：this.handleClick=this.handleClick.bind(this),或者是这样的代码：<button onClick={()=>this.handleClick(e)}>。一旦我们不小心忘了绑定 this，各种 bug 就随之而来，很麻烦。

还有一件让我们很苦恼得到事情。尽可能把你的组件写成无状态组件的形式，因为他们更方便复用，可以独立测试。然而很多时候，我们用 function 写了一个简洁的完美的无状态组件，后来因为需求变动这个组件必须得有自己的 state，我们又得很麻烦的把 function 改为 class。

#### 什么是 State Hooks

回到一开始我们用的例子，我们分解来看到底 state hooks 做了什么。

```js
import { useState } from "react";
function Example() {
  const [count, setCount] = useState(0);
  return (
    <div>
      <p>You clicked {count} timers</p>
      <button onClick={() => setCount(count + 1)}>Click me</button>
    </div>
  );
}
```
